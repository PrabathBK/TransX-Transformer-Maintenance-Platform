# TransX - Transformer Maintenance Platform: AI Development Guide

## Architecture Overview

TransX is a **4-phase full-stack system** for thermal image inspection and anomaly detection in electrical transformers. The architecture is **service-oriented** with clear separation:

- **Frontend** (React/TypeScript, Vite): Interactive inspection UI with Konva.js canvas
- **Backend** (Spring Boot, Java 21): REST API layer with JPA/Hibernate persistence
- **ML Service** (Flask, Python): YOLOv8-based inference server running on separate port
- **Database** (MySQL 8.0+): Relational schema with UUID primary keys for all entities
- **Storage**: File-based uploads with UUID-prefixed directories

**Key Data Flow**: Frontend uploads image → Backend receives → ML Service infers → Annotations persisted → Frontend renders

## Multi-Service Development Workflow

**All three services must run simultaneously** for full functionality:

```bash
# Terminal 1: ML Service (port 5001)
cd transformer-inspector/ml-service
source venv/bin/activate
python app.py

# Terminal 2: Backend (port 8080)
cd transformer-inspector/backend
./gradlew bootRun

# Terminal 3: Frontend (port 5173)
cd transformer-inspector/frontend
npm run dev
```

**Health check endpoints**:
- Backend health: `curl http://localhost:8080/api/health`
- ML service health: `curl http://localhost:5001/api/health`
- Frontend: `http://localhost:5173`

## Core Patterns & Conventions

### 1. **Request-Response Contracts (DTOs)**
All backend REST endpoints use **strict DTO contracts** defined in `backend/src/main/java/com/acme/backend/api/dto/`:
- Request DTOs: `Create*Req.java`, `Update*Request.java`
- Response DTOs: `*DTO.java`, `DetectionResponse.java`
- **Do NOT modify response structures without frontend coordination** — they map 1:1 to TypeScript interfaces

Example endpoint signature:
```java
@PostMapping
public ResponseEntity<AnnotationDTO> createAnnotation(@RequestBody CreateAnnotationReq req)
```

### 2. **Automatic API Call Pattern (No Manual Save)**
Frontend **auto-persists ALL user actions** without explicit "Save" buttons:
- User draws/edits annotation → `onAnnotationUpdate` callback fires immediately
- Each action (`ADD`, `EDIT`, `DELETE`, `APPROVE`, `REJECT`) triggers API call via `frontend/src/api/annotations.ts`
- Backend immediately persists to database + logs to `annotation_history` table for versioning
- **Implication**: Error handling must be frontend-visible; show toast/alert on API failure

### 3. **ML Service Integration Points**
Backend calls Flask ML service at:
- **Detection trigger**: `POST /api/inspections/{id}/detect-anomalies` → calls `POST http://localhost:5001/api/detect`
- **Class definitions**: `GET http://localhost:5001/api/classes` (caches fault types: Faulty, faulty_loose_joint, faulty_point_overload, potential_faulty)
- **Health check**: `GET /api/inspections/ml-service/health` before allowing detection

Model outputs are **coordinates only** (x1, y1, x2, y2 + confidence), not rendered images. Frontend renders boxes via Konva.js on top of original image.

### 4. **Canvas Rendering with Konva.js**
`AnnotationCanvas.tsx` uses **react-konva** for interactive drawing/editing:
- **Modes**: `'view'` (read-only), `'draw'` (create boxes), `'edit'` (modify existing boxes)
- **Key refs**: `stageRef`, `transformerRef` for Konva Stage/Transformer objects
- **Events**: Mouse down/up for drawing; stage click handlers for selection
- **State tracking**: `selectedId` (currently selected box), `isDrawing` (mid-draw flag), `scale` (zoom level), `stagePos` (pan offset)
- **Image auto-scaling**: Large images (640-3077px) are scaled to fit canvas while preserving aspect ratio (see `useEffect` hook ~line 48)

### 5. **File Upload & Storage**
- Frontend sends `FormData` with file → Backend `FileStorageService` generates **UUID directory** + preserves original filename
- Storage path: `{app.storage.root}/{UUID}/{original_filename}`
- Public access: `/files/{UUID}/{original_filename}` served by `StaticFileConfig.java`
- **Each inspection has single image at a time** — uploading new image replaces previous one

### 6. **Entity Relationships & UUIDs**
- All primary keys are **UUID (binary(16))**, generated by JPA `@GeneratedValue` with `UuidGenerator`
- Foreign keys reference UUIDs (e.g., `Annotation.inspectionId` → `Inspection.id`)
- **Cascade deletes** configured: deleting inspection cascades to annotations, comments, history
- Timestamps auto-set: `@CreationTimestamp`, `@UpdateTimestamp` on entities

## Key File Locations & Responsibilities

| Location | Purpose |
|----------|---------|
| `backend/src/main/java/com/acme/backend/api/` | REST controllers (Annotation, Inspection, Transformer, Comment, Image, Health) |
| `backend/src/main/java/com/acme/backend/service/` | Business logic; `MLServiceClient.java` handles Flask communication |
| `backend/src/main/java/com/acme/backend/domain/` | JPA entities (Inspection, Annotation, InspectionComment, Transformer, ThermalImage) |
| `backend/src/main/java/com/acme/backend/repository/` | JPA repositories; custom queries for inspection filtering, annotation retrieval |
| `backend/storage/FileStorageService.java` | UUID directory generation, file serving, upload handling |
| `frontend/src/api/` | Typed API clients (`annotations.ts`, `inspections.ts`, `transformers.ts`, `images.ts`, `client.ts` base) |
| `frontend/src/components/AnnotationCanvas.tsx` | Core Konva.js canvas; 433 lines, handles draw/edit/view modes |
| `frontend/src/pages/InspectionDetailNew.tsx` | Main inspection interface; 1608 lines orchestrating canvas, comments, history |
| `ml-service/app.py` | Flask server; loads YOLOv8 model, `/api/detect` runs inference, `/api/classes` returns fault types |

## Inspection & Annotation Lifecycle

1. **Create Inspection**: `POST /api/inspections` with transformer ID
2. **Upload Image**: `POST /api/inspections/{id}/upload-image` with file FormData
3. **Trigger Detection**: `POST /api/inspections/{id}/detect-anomalies` → ML service infers → stores auto-generated annotations (source='ai')
4. **User Feedback**: Frontend loads annotations via `GET /api/annotations?inspectionId={id}`, renders on canvas
5. **Approve/Reject**: `POST /api/annotations/{id}/approve` or `POST /api/annotations/{id}/reject` → updates action_type + is_active flag
6. **Manual Edits**: `PUT /api/annotations/{id}` for user-drawn boxes (source='human')
7. **Complete Inspection**: `PUT /api/inspections/{id}/status` → marks status as COMPLETED
8. **Export**: `GET /api/annotations/feedback/export?inspectionId={id}` → JSON feedback data for ML fine-tuning

## Configuration & Environment

### Backend (`application.properties`)
```properties
spring.datasource.url=jdbc:mysql://localhost:3306/en3350_db
spring.datasource.username=root
spring.datasource.password=<your_password>
app.ml-service.url=http://localhost:5001
app.cors.allowed-origins=http://localhost:5173
app.storage.root=<absolute_path_to_uploads>
```

### Frontend (environment)
- `VITE_API_BASE`: Defaults to `http://localhost:8080` (set in `src/api/client.ts`)
- Build: `npm run build` → `dist/` folder
- Lint: `npm run lint` (ESLint config)

### ML Service
- Model path: `../Faulty_Detection/yolov8p2.pt` (must exist)
- Confidence threshold: Configurable per request, default 0.25 in `app.py`

## Common Development Tasks

### Adding a New Annotation Field
1. Update `Annotation.java` entity (add @Column)
2. Update `AnnotationDTO.java` (add field)
3. Update `CreateAnnotationReq.java` (add field)
4. Update `AnnotationCanvas.tsx` rendering logic (CLASS_COLORS map, box drawing)
5. Update API client `frontend/src/api/annotations.ts` if request structure changed
6. Test via `POST /api/annotations` with new field

### Triggering Detection on a New Image Size
- Canvas already auto-scales (line ~48 in `AnnotationCanvas.tsx`)
- ML service handles any image size; verify model input preprocessing in `app.py`
- Test: Upload 3077x1920 image, verify bounding boxes appear at correct pixel positions

### Adding a Comment to an Inspection
- Frontend: `CommentsSection.tsx` component calls `createInspectionComment()` from `api/inspectionComments.ts`
- Backend: `InspectionCommentController.java` → `InspectionCommentService.java` → saves to `inspection_comments` table
- Real-time: Frontend re-fetches comments after create; component polls or manually refetch

### Exporting Annotations for Model Retraining
- Endpoint: `GET /api/annotations/feedback/export?inspectionId={id}`
- Response format: JSON with original AI detections + final user annotations
- Usage: Feed to `ml-service/targeted_dataset_creator.py` to generate YOLO dataset, then finetune with `train_yolo_fixed.py`

## Testing & Debugging

### Backend Unit Tests
- Located: `backend/src/test/java/com/acme/backend/`
- Run: `./gradlew test`
- Controller tests use MockMvc for REST endpoint testing

### ML Service Health Debugging
```bash
curl http://localhost:5001/api/health
# Should return: {"status": "healthy", "model_loaded": true, ...}
```

### Database Schema Inspection
- Use MySQL Workbench or CLI: `mysql -u root -p en3350_db`
- Key tables: `inspections`, `annotations`, `annotation_history`, `inspection_comments`, `thermal_images`, `transformers`
- UUID columns: stored as `binary(16)`, query with `CAST` or UUIDs directly in WHERE clauses

### Frontend Canvas Issues
- Open browser DevTools → Console for React errors
- Check Konva.js stage dimensions: `stageRef.current.width()` / `.height()`
- Verify image loaded: `img.onload` fired in `useEffect` hook
- Test zoom/pan: Call `onZoomChange` callbacks to trigger canvas methods

## Common Pitfalls & Solutions

| Issue | Root Cause | Solution |
|-------|-----------|----------|
| ML service returns empty detections | Model confidence < threshold or image format issue | Lower `confidence_threshold` in request; verify image is RGB/valid thermal image |
| Annotations not visible on canvas | Scale/position mismatch between image and bounding box coords | Verify image dimensions match in Annotation entity; check canvas scaling in `AnnotationCanvas` |
| CORS errors on frontend API calls | Backend CORS config doesn't include frontend origin | Update `app.cors.allowed-origins` in `application.properties`; restart backend |
| Large image upload timeout | ML service inference > 30s | Increase `app.ml-service.timeout` in config; optimize model or reduce image resolution |
| Comments not persisting | API call failed silently | Check network tab in DevTools; ensure `InspectionCommentController` POST endpoint runs without exception |

## Code Style & Standards

- **Java**: Follow Spring Boot conventions; use dependency injection (@Service, @Repository); package entities, DTOs, controllers separately
- **TypeScript**: Strict mode enabled (`tsconfig.json`); use interfaces for types; prefer `const` over `let`; async/await over `.then()`
- **React**: Functional components + hooks; use `useCallback` for memoized event handlers; avoid inline functions in JSX
- **Python**: Flask route handlers; type hints encouraged; use `try-except` around inference to catch model errors
- **Git**: Branch naming: `feature/`, `bugfix/`, `authentication`; commit messages should reference phase/component

## Resources & References

- **YOLOv8 Docs**: [ultralytics](https://docs.ultralytics.com)
- **Spring Boot Docs**: [spring.io](https://spring.io/projects/spring-boot)
- **React Hooks**: [react.dev](https://react.dev)
- **Konva.js**: [konvajs.org](https://konvajs.org)
- **MySQL 8.0**: [dev.mysql.com](https://dev.mysql.com/doc/refman/8.0/en/)
